--------------------
String
--------------------
*
  - str.compareTo(str2)
  - str.split(regx)
  - str.join(" ", strArr)
  - Integer.parseInt

* Split by Regx and compare
  - 165. Compare Version Numbers

* add cols and check if cut string instead of add string and compare cols
  - 418. Sentence Screen Fitting

* palindromic
  - 647 Palindromic Substrings

** Convert integer to english words
  - 273. Integer to English Words
    # Recursion, Math

* Buffer
  - 157. Read N Characters Given Read4
  - 158. Read N Characters Given Read4 II - Call multiple times

* Roman to integer
  - 13. Roman to Integer
  - 12. Integer to Roman

* Build Strobogrammatic Number with dfs with l, r。单双情况
  - 248. Strobogrammatic Number III

* Shift String
  - 249. Group Shifted Strings

- 161. One Edit Distance
    # String

- 43. Multiply Strings
    # String

- 38. Count and Say
    # String

- 68. Text Justification
    # String

- 269. Alien Dictionary
- 1249. Minimum Remove to Make Valid Parentheses

--------------------
LinkedList
--------------------
* Doubly Linkedlist, dummy head, tail node
  - 146 LRU(Least Recently Used) Cache
    # Doubly LinkedList, HashMap

* Reverse linkedlist, slow/fast pointer
  - 234 Palindrome Linked List
  - 160. Intersection of Two Linked Lists
  - 142 Linked List Cycle II

- 2. Add Two Numbers

--------------------
Array
--------------------
*
  - Arrays.sort(s)
  - Collections.sort(intervals, (x,y) -> x.start - y.start);

* Map array value to array index
  - 41. First Missing Positive
        # Array, Index
  - 448 Find All Numbers Disappeared in an Array
  - 268. Missing Number
        # Array, 高斯公式

* Intervals. Split to start and end array and sort them.
  - 56. Merge Intervals
  - 253. Meeting Rooms II
    # Array, Sort

* insert interval
  - 57. Insert Interval
  - 731. My Calendar II

* Matain max, min, res
  - 152. Maximum Product Subarray

* sum up to current index, and matain sum map
  - 560. Subarray Sum Equals K
  - 325. Maximum Size Subarray Sum Equals k

* matain remainder index map instead of sum index map
  - 523. Continuous Subarray Sum

* matain max array and compare with index
  - 769. Max Chunks To Make Sorted

* 3 for loop, fixed 2 rows and loop cols
  - 750. Number Of Corner Rectangles
    # 2D Array, Math

* array 中每个value=min(l,r,u,d), 神循环
  - 764. Largest Plus Sign
    # 2D Array
  - 361. Bomb Enemy

* int[256] matains previous visited index
  - 3. Longest Substring Without Repeating Characters
    # Two Pointers

* 左到右依次少乘本身，然后右到左乘以right（nums右到左product）
  - 238. Product of Array Except Self

* Rotate array, left to top, bottom to left, ...top to right
  - 48 Rotate Image

* spiral matrix
  - 54. Spiral Matrix
    # 2D Array
  - 59. Spiral Matrix II
    # 2D Array

* search in sorted rows and cols array
  - 240 Search a 2D Matrix II

* matain largest sum index in array
  - 689. Maximum Sum of 3 Non-Overlapping Subarrays
    # Array, DP

- 289. Game of Life
    # 2D Array

- 670. Maximum Swap

--------------------
Stack
--------------------
* calculate expression
  - 150. Evaluate Reverse Polish Notation

* maintain number stack and res stack and current res
  - 394. Decode String

** find next greater element in arr
  - 496. Next Greater Element I
  - 503. Next Greater Element II
  - 739. Daily Temperatures

* parentheses
  - 20 Valid Parentheses

* parentheses, push index into stack
  - 32 Longest Valid Parentheses

* parentheses, remove invalid parentheses
  - 301 Remove Invalid Parentheses
      # Backtracking/DFS, Two Pointers

** Matain increasing order index in stack, pop if new height lower than stack.peek(). Calculate h[stack.pop()] * (i-stack.peek()-1)
  - 84 Largest Rectangle in Histogram
  - 85. Maximal Rectangle

* Calculate time for process
  - 636. Exclusive Time of Functions

* Regular expression to split string, put into stack
  - 71. Simplify Path

--------------------
Tree
--------------------
* recursion on 2 nodes and compare
  - 101 Symmetric Tree

* matain max sum for each path using recursion
  - 124 Binary Tree Maximum Path Sum

* Postorder traversal and serialize subtree to string
  - 652. Find Duplicate Subtrees
    # Tree, Postorder Traversal, Serialize

* post order 返回个数，思路像124
  - 298. Binary Tree Longest Consecutive Sequence
      # PostOrder, Tree

* DP in tree
  - 337. House Robber III
      # Tree, DP

* lowest common ancestor
  - 236 Lowest Common Ancestor of a Binary Tree

* construct tree from Preorder and Inorder Traversal
  - 105 Construct Binary Tree from Preorder and Inorder Traversal

* level traversal, preorder
  - 102 Binary Tree Level Order Traversal
  - 117. Populating Next Right Pointers in Each Node II
      # Tree, Level Traversal, Queue

* flatten tree, right -> left
  - 114. Flatten Binary Tree to Linked List
      # PostOrder, Tree

* Tree inorder iterative traversal with stack
  - 94. Binary Tree Inorder Traversal
      # Inorder Traversal, Stack
  - 173. Binary Search Tree Iterator
      # Stack
  - 98. Validate Binary Search Tree
      # Stack

* path sum from any node
  - 437. Path Sum III
      # PreOrder on sum, PostOrder on res, Tree, DFS

* vertical order traversal using BFS
  - 314. Binary Tree Vertical Order Traversal
      # Tree, BFS, Queue

* Search Value in tree
  - 270. Closest Binary Search Tree Value
  - 285. Inorder Successor in BST
        # Tree, Successor

* 297. Serialize and Deserialize Binary Tree
    # BFS, Preorder Traversal, Tree

* Matain first and last node while inorder traversal
  - 426. Convert Binary Search Tree to Sorted Doubly Linked List
    # Inorder

--------------------
Trie/Prefix Tree
--------------------
* add, find word in trie, "." means any character
  - 211. Add and Search Word - Data structure design

* encode prefix and suffix to integer, combine prefix and suffix tree
  - 745. Prefix and Suffix Search

* Create shortest abbreviation for each word, for duplicates, increase abbreviation length util not duplicates
- 527. Word Abbreviation
    # String, Trie

- 208. Implement Trie (Prefix Tree)

--------------------
HashSet
--------------------
* find consecutive number by going up and down
  - 128. Longest Consecutive Sequence
      # HashSet

* encode to category，牛
  - 36. Valid Sudoku
    # HashSet

--------------------
HashMap
--------------------
* Contiguous Array 类型, consider HashMap and Two Pointers
  - 525. Contiguous Array

- 205. Isomorphic Strings
- 1. Two Sums

--------------------
Two Pointers
--------------------
* Think of two pointers when question incldues consecutive / substring / palindrome / sliding.

** Sliding window
  - 438. Find All Anagrams in a String
  - 76 Minimum Window Substring

* Matain index queue of decending num. Use queue to operate on both sides rather than stack
  - 239. Sliding Window Maximum

* matain index stack of incresing/decreasing num
  - 581. Shortest Unsorted Continuous Subarray
      # Monotonic, Stack

* two pointers, water
  - 11 Container With Most Water
  - 42. Trapping Rain Water
        # Two Pointers

* 3 partition
  - 75 Sort Colors
  - 15. 3Sum
    # Two Pointers, Sort, Edge Case

* palindrome: while l<r, compare and l--, r--
  - 125. Valid Palindrome
  - 680. Valid Palindrome II

* create sum array, fast and slow pointers
  - 209. Minimum Size Subarray Sum

- 340. Longest Substring with At Most K Distinct Characters
    # Two Pointers, HashMap

--------------------
Binary Search
--------------------
Approach 1. l<=r
   - l=mid+1, r=mid-1 可能会越界，所以要不返回target，要不越界找不到
   - l=mid+1, r=mid 可能会死循环卡在r=mid上，可能越界

Approach 2. l < r
   - l=mid+1, r=mid 最后都返回l.不会越界
     - mid < target, 1st that >= target
     - mid = target,

Approach 3. l < r-1
   - l=mid, r=mid, based on check, 返回l或者r或者null。不会越界

* cut1 and cut2= length/2-cut1, l1, r1, l2, r2
  - 4 Median of Two Sorted Arrays

* Approach 2
  - 287 Find the Duplicate Number
    - l < r, mid <= target, l = mid+1, r = mid, find 1st elem > target
    # Binary Search, unsorted array

  - 300. Longest Increasing Subsequence
    - l < r, mid < target, l = mid+1,r = mid, find 1st elem that >= target.
      # Binary Search, patience sort

* find leftmost and rightmost, Approach 3
  - 34 Search for a Range
    - leftmost  l<r-1, mid<target, l=mid, r=mid
    - rightmost l<r-1, mid<=target, l=mid, r=mid
    # Binary Search

* Approach 1, find target return, else l=mid+1 and r=mid-1
  -     while(l<=r) {
            int mid = l + (r-l)/2;
            if(citations[mid] == size -mid) {
                return size-mid;
            } else if(citations[mid] < size - mid) {
                l = mid +1;
            } else {
                r = mid-1;}}
        return size-l;
  - 275. H-Index II

* find bad version
  - 278. First Bad Version
    - Approach 2, 3都行

* compare mid & mid-1, compare mid & (left || right)
  - 33. Search in Rotated Sorted Array
        # Binary Search, Array
  - 153. Find Minimum in Rotated Sorted Array
        # Binary Search, Array

* 理解l<r 还是l<=r, l=mid+1 r=mid 边界条件
  - 162. Find Peak Element
        - compare mid with mid + 1
        - Approach 2, 不会越界和必有结果
        # Binary Search

* compare left tree height and right tree height
  - 222. Count Complete Tree Nodes
        # Binary Search, Tree, Complete Tree

* Matain longest increasing subsequence
  - 300. Longest Increasing Subsequence
  - 334. Increasing Triplet Subsequence

* Matain list of char sequence index list for each char in String t
  - 392. Is Subsequence
      # Binary Search

* find single element
  - 540. Single Element in a Sorted Array
      # Binary Search

- 69. Sqrt(x)
    - Approach 3, can't use Approach 2
    # Binary Search

- 50. Pow(x, n)
    # Binary Search

--------------------
Binary Search Tree
--------------------
* Matain (start, end, overlap) time using binary search tree.
  - 731. My Calendar II

--------------------
Graph
--------------------
* convert letter sequence to directed graph and use topological sort
  - 269. Alien Dictionary
    # Topological Sort, DFS, Directed Graph, Character order

--------------------
BFS
--------------------
1. Shortest path, in K stop/steps

* Shortest Path
  - 127. Word Ladder

* Shortest Path, encode int[][] to string and keep Set<String> visited
  - 773. Sliding Puzzle
  - 787. Cheapest Flights Within K Stops
  - 815. Bus Routes

* color node
  - 785. Is Graph Bipartite
    # Graph, BFS

--------------------
DFS
--------------------
1. cycle detection in directed graph
2. find/construct/generate path

* Combine DFS and Tree Generation
    - 95. Unique Binary Search Trees II
        # DFS, Tree, Postorder

* Cycle detection, directed graph
  - 207. Course Schedule
      # DFS, Topological Sort, Graph, Adjacent List, Cycle Detection, Back Edge
  - 210. Course Schedule II
      # Directed Graph, Topological Sort, Stack

* Maze, ball moving with direction
  - 490. The Maze
    # DFS
  - 505. The Maze II
    # BFS, Shortest Path
  - 499. The Maze III
    # BFS, Shortest Path

* Calculate minnum # to sum each num in list to 0
  - 465. Optimal Account Balancing

* Construct all strings
  - 753. Cracking the Safe

** integer arr to expression, keep pre during dfs for calculation
  - 282. Expression Add Operators

* undirected graph clone, self cycle
  - 133. Clone Graph

- 341. Flatten Nested List Iterator
- 37. Sudoku Solver
- 286. Walls and Gates
- 529. Minesweeper
- 802. Find Eventual Safe States

--------------------
Union Find
--------------------
1. cycle detection in undirected/directed graph.
2. connected component
3. 分类 e.g. 737

* track connected component
  - 305. Number of Islands II
    # Union Find

* Convert equation to graph, use Map instead of array to matain parent relation
  - 399. Evaluate Division

* detect cycle and multiple parents in undirected and directed graph
  - 684. Redundant Connection
  - 685. Redundant Connection II

* detect cycle in undirected graph
  - 261. Graph Valid Tree

* interesting couple swap
  - 765. Couples Holding Hands

* String union find, Map<String, String>
  - 737. Sentence Similarity II

* 分类
  - 721. Accounts Merge

--------------------
Priority Queue
--------------------
* Use minHeap and maxHeap to maintain median
  - 295. Find Median from Data Stream

- 218. The Skyline Problem
- 973. K Closest Points to Origin

----------------------------------
Fenwick Tree / Binary Indexed Tree
----------------------------------
* get sum of prefix VS segment tree get sum of given range
  - 315. Count of Smaller Numbers After Self

* 2D Binary Indexed Tree
  - 308. Range Sum Query 2D - Mutable

--------------------
Sort
--------------------
* LinkedList merge sort
  - 148 Sort List
  - 23 Merge k Sorted Lists

* counting sort, sort on anagrams
  - 49 Group Anagrams

* bucket sort, maximum frequence is fixed
  - 347 Top K Frequent Elements
  - 274. H-Index
    # Bucket Sort

* sort int[][] arr by sort 2 dimension
  - 406 Queue Reconstruction by Height

* Quick sort, kth largest element
  - 215 Kth Largest Element in an Array

--------------------
Backtracking
--------------------
1. related to dfs
2. check duplicate or not
3. recursion includes array, startIndex, res ...

* number of left parentheses is always >= right
  - 22 Generate Parentheses

* arr has duplicate, sort and dfs(ignore if pre==cur) to create subset
  - 90. Subsets II
  - 78 Subsets

- 46 Permutations
- 17 Letter Combinations of a Phone Number
- 39. Combination Sum

--------------------
Math
--------------------
* Generate random index
  - 398. Random Pick Index

* friends request
  - 825. Friends Of Appropriate Ages
    # Array, Continuous array, Math

* 10进制变成26进制
  - 168. Excel Sheet Column Title
    # Math

--------------------
Greedy
--------------------
- 621. Task Scheduler
    # Greedy, Math

- 134. Gas Station
    # Greedy

* Matain pre and # of consecutive sequence at pre with length 1, 2, 3
    - 659. Split Array into Consecutive Subsequences
      # Greedy

--------------------
Bit Mnaipulation
--------------------
* x ^ y, x&1, x >> 1
  - 136 Single Number
  - 461 Hamming Distance

* 统计1，0个数后相乘 for 32 digit
  - 477. Total Hamming Distance

* i&(i - 1)， 这个本来是用来判断一个数是否是2的指数的快捷方法，比如8，二进制位1000, 那么8&(8-1)为0，只要为0就是2的指数
  - 338 Counting Bits

--------------------
Design
--------------------
* Buffer
  - 359. Logger Rate Limiter
        # Design, Scale, Buffer, HashSet
  - 362. Design Hit Counter
        # Design, Scale, Buffer
  - 346. Matainoving Average from Data Stream
        # Design, Queue, Buffer

* Matain HashMap of val and index, and ArrayList
  - 380. Insert Delete GetRandom O(1)

- 146. LRU Cache
    # Double LinkedList, HashMap

--------------------
Dynamic Programming
--------------------
* 1D
  - 198 House Robber

* 2 for loops, 以target num为第一循环，单词或者coins或者each array为第二循环
  - 139 Word Break
      # 1D DP
  - 279 Perfect Squares
      # 1D DP
  - 322. Coin Change
      # 1D DP
  - 377. Combination Sum IV
      # 1D DP, Backtracking, Target DP

* Decode
  - 91. Decode Ways
        # 1D
  - 639. Decode Ways II
        # 1D

* create student attendance with A, L, P
  - 552. Student Attendance Record II
        # 1D

* Unique binary search tree, 2 for loops
  - 96 Unique Binary Search Trees
    # 1D DP

* simple path sum
  - 64 Minimum Path Sum
      # 2D DP

* String Matching, row is string/convert from, column is pattern/convert to
  - 10. Regular Expression Matching
        # 2D DP
  - 44. Wildcard Matching
        # 2D DP
  - 72. Edit Distance (template for 2d DP)
        # 2D DP
  - 115. Distinct Subsequences
        # 2D DP, DFS

* palindromic, 2 for loops, s.charAt(i) == s.charAt(j) && dp[i+1][j-1]
  - 5 Longest Palindromic Substring
    # 2D DP

* buy and sell stock
  - 122. Best Time to Buy and Sell Stock II
      # Greedy
  - 309. Best Time to Buy and Sell Stock with Cooldown
      # 2个 1D DP
  - 714. Best Time to Buy and Sell Stock with Transaction Fee
      # 2个 1D DP
  - 123. Best Time to Buy and Sell Stock III
      # 1D DP

* maximax square
  - 221. Maximal Square
      # 2D DP

* Matain startIndex instead of boolean dp[][]
  - 727. Minimum Window Subsequence
        # 2D DP

* use sum range as cols, elements as rows
  - 494. Target Sum
        # 2D

* n个ballon从1个开始循环，2个，最后n个
  - 312. Burst Balloons

** Recursion, memorization, 2D
  - 486. Predict the Winner
    # Recursion, Memorization, 2D

* array中新的value跟过去的value有关
  - 264. Ugly Number II
    # Array, 类似DP

* 4 conditions, 不用dfs，dp
  - 1007
    # Greedy

- 801. Minimum Swaps To Make Sequences Increasing

--------------------
SQL
--------------------
- 602. Friend Requests II: Who Has the Most Friends
- 578. Get Highest Answer Rate Question

